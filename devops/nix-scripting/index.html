<!doctype html><html lang=en><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="ie=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=author content="Phil Proctor "><meta name=description content="Scripting is among the most common tasks that we have in the world of devops, but have you ever ran into the situation where the moment someone else goes to run one of your scripts, it immediately fails because their environment is slightly different from your own? What about your CI environment, is it different too? Creating consistent environments is a consistent pain point.
So what next? Write up a set of instructions for what utilities need to be installed?"><meta name=keywords content=",devops,scripting,nix,posts"><meta name=robots content="noodp"><meta name=theme-color content><link rel=canonical href=/devops/nix-scripting/><title>Actual Portable Scripting with Nix :: The Viking</title><link rel=stylesheet href=/main.8c0d5dad1b82dce29b6f3f9dff7e30ad67db86a791c239b2efb6c6cb6434c514.css integrity="sha256-jA1drRuC3OKbbz+d/34wrWfbhqeRwjmy77bGy2Q0xRQ="><link rel=stylesheet type=text/css href=/css/asciinema-player.css><script src=/js/asciinema-player.min.js></script>
<link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/site.webmanifest><link rel=mask-icon href=/safari-pinned-tab.svg color><link rel="shortcut icon" href=/favicon.ico><meta name=msapplication-TileColor content><meta itemprop=name content="Actual Portable Scripting with Nix"><meta itemprop=description content="Scripting is among the most common tasks that we have in the world of devops, but have you ever ran into the situation where the moment someone else goes to run one of your scripts, it immediately fails because their environment is slightly different from your own? What about your CI environment, is it different too? Creating consistent environments is a consistent pain point.
So what next? Write up a set of instructions for what utilities need to be installed?"><meta itemprop=datePublished content="2024-01-25T09:00:00-04:00"><meta itemprop=dateModified content="2024-01-25T09:00:00-04:00"><meta itemprop=wordCount content="1875"><meta itemprop=image content="/"><meta itemprop=keywords content="devops,scripting,nix,posts,"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="/"><meta name=twitter:title content="Actual Portable Scripting with Nix"><meta name=twitter:description content="Scripting is among the most common tasks that we have in the world of devops, but have you ever ran into the situation where the moment someone else goes to run one of your scripts, it immediately fails because their environment is slightly different from your own? What about your CI environment, is it different too? Creating consistent environments is a consistent pain point.
So what next? Write up a set of instructions for what utilities need to be installed?"><meta property="og:title" content="Actual Portable Scripting with Nix"><meta property="og:description" content="Scripting is among the most common tasks that we have in the world of devops, but have you ever ran into the situation where the moment someone else goes to run one of your scripts, it immediately fails because their environment is slightly different from your own? What about your CI environment, is it different too? Creating consistent environments is a consistent pain point.
So what next? Write up a set of instructions for what utilities need to be installed?"><meta property="og:type" content="article"><meta property="og:url" content="/devops/nix-scripting/"><meta property="og:image" content="/"><meta property="article:section" content="devops"><meta property="article:published_time" content="2024-01-25T09:00:00-04:00"><meta property="article:modified_time" content="2024-01-25T09:00:00-04:00"><meta property="article:published_time" content="2024-01-25 09:00:00 -0400 -0400"></head><body><div class=container><header class=header><span class=header__inner><a href=/ style=text-decoration:none><div class=logo><span class=logo__mark>âž¤</span>
<span class=logo__text>theviking.tech</span>
<span class=logo__cursor style=background-color:#12a212;animation-duration:2s></span></div></a><span class=header__right><nav class=menu><ul class=menu__inner><li><a href=/about>About</a></li><li><a href=/devops>Devops</a></li><li><a href=/general>General</a></li></ul></nav><span class=menu-trigger><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M0 0h24v24H0z" fill="none"/><path d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z"/></svg></span><span class="theme-toggle not-selectable"><svg class="theme-toggler" width="24" height="24" viewBox="0 0 48 48" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M22 41c10.4934.0 19-8.5066 19-19C41 11.5066 32.4934 3 22 3 11.5066 3 3 11.5066 3 22s8.5066 19 19 19zM7 22C7 13.7157 13.7157 7 22 7V37C13.7157 37 7 30.2843 7 22z"/></svg></span></span></span></header><div class=content><main class=post><div class=post-info></p></div><article><h2 class=post-title><a href=/devops/nix-scripting/>Actual Portable Scripting with Nix</a></h2><div class=post-content><p>Scripting is among the most common tasks that we have in the world of devops, but have you ever ran into the situation where
the moment someone else goes to run one of your scripts, it immediately fails because their environment is slightly different
from your own? What about your CI environment, is it different too? Creating consistent environments is a consistent pain
point.</p><p>So what next? Write up a set of instructions for what utilities need to be installed? Create a <code>Dockerfile</code> with all
of the <code>apt-get</code> installs? Do instructions for people, Dockerfile for CI? Containerize everything and map host paths
to the host machines config files and whatnot?</p><p>Each of these solutions comes with their own compromises. Additionally, these solutions are very likely to break
over time when <a href=https://learn.microsoft.com/en-us/cli/azure/upcoming-breaking-changes>packages update with breaking changes</a>,
packages get removed, or any number of other scenarios. This leads to having to update instructions, Dockerfiles, scripts,
and so forth at what is likely a very inconvenient time and after you&rsquo;ve already forgotten how those scripts work!</p><p>Well, we don&rsquo;t have to deal with that&mldr; ok, maybe still a little, but at least our packages won&rsquo;t change underneath us.</p><h2 id=introducing-nix>Introducing Nix</h2><p>So what is Nix exactly? Just another package manager? It&rsquo;s a bit more than that, but to fully understand, consider
how these problems are solved elsewhere. We are likely all familiar at this point with the package management systems
that come with various languages.</p><ul><li>Nuget for C#</li><li>NPM for node.js</li><li>pip/venv for Python</li><li>The list here could get very long&mldr;</li></ul><p>If you think about a generic package management solution for scripting, you are probably thinking about <code>apt-get</code> or <code>yum</code>.
These, however, have several distinct disadvantages over the solutions listed above:</p><ul><li>These utilities are tied to the OS and thus vary significantly between machines (redhat, debian, arch, etc.)</li><li>It is unlikely that the versions of the utilities two people end of using are the same (my version of bash is 5.2.15, what&rsquo;s yours?)</li><li>They don&rsquo;t provide any package locking type solutions</li><li>Each package manager doesn&rsquo;t even have the same library of utilities available</li></ul><p>Nix fixes all of these problems. Additionally, it fixes it regardless of the OS the user is using and allows you to fully define
<strong>everything</strong> about the execution environment of the scripts you are running. Nix is powerful enough that it can even be used to replace
the package management systems above, though usually the preferred route is to simply tie into those systems.</p><p>Too good to be true? Well, no system is perfect. There are significant drawbacks to Nix, including poor documentation and a difficult
to understand configuration language. Fortunately, for our purposes here, these drawbacks will be mitigated by setting up a relatively
unchanging scaffolded environment.</p><h2 id=bowls-of-nix-flakes>Bowls of Nix Flakes</h2><p><a href=https://nixos.wiki/wiki/Flakes>Nix Flakes</a> is the system we use to provide both package locking and execution environment management.
I have created <a href=https://github.com/philproctor/nix-script-runner-demo>this demo here</a> to show a solid setup for using flakes, so let&rsquo;s
break down the demo and see how it works!</p><div id=asciinema-nix1></div><script>AsciinemaPlayer.create("nix1.cast",document.getElementById("asciinema-nix1"),{autoPlay:!0,loop:!0,idleTimeLimit:2,theme:"asciinema",controls:!1,cols:"140",rows:"16",speed:"2"})</script><p>From the above demo you can see that when you run one of the scripts in the demo are run for the first time, all of the dependendent utilities
for the script are automatically downloaded and made available to the script environment! This means that any utilities that you need in
your script, such as <code>jq</code>, <code>kubectl</code>, or just about anything else are automatically pulled without you as a user needing to think about it
at all! Your end users do not need to preinstall <strong>anything</strong> except for nix itself!</p><h2 id=our-customized-scaffold>Our Customized Scaffold</h2><p>The scaffolding is primarily handled through the <code>flake.nix</code> file, but additionally includes an easy-of-use wrapper for running scripts.</p><h3 id=the-run-wrapper>The ./run Wrapper</h3><p>The <a href=https://github.com/philproctor/nix-script-runner-demo/blob/main/run>./run wrapper</a> is used to make executing individual scripts easier,
especially for users of your project who are not familiar with the (quite quirky) nix command line. Additionally, the wrapper includes some
basic messaging if the user doesn&rsquo;t have the nix tools installed or forgets to specify which script to execute. As most of this wrapper is
self-explanatory, let&rsquo;s move on to the guts of our scaffolding: <code>flake.nix</code></p><h3 id=diving-in-to-our-customized-nix-flake>Diving in to our Customized Nix Flake</h3><p>One of the biggest concerns I have had with using the Nix tooling in projects with a wider and mixed skillset is that we don&rsquo;t want to require
everyone on the team or users of the project to need to learn and understand <strong>Yet Another Domain Specific Languageâ„¢</strong> just to solve package
management requirements around our primary scripts. So <a href=https://github.com/philproctor/nix-script-runner-demo/blob/main/flake.nix>here&rsquo;s out attempt to gain these advantages without requiring users to fully understand
Nix</a>.</p><p>The basic structure of using <code>inputs = {...</code> and <code>outputs = {...</code> is defined by the <a href=https://nixos.wiki/wiki/Flakes#Flake_schema>Flake schema</a>.
You may notice that we are using <code>nixpkgs-unstable</code> as one of our inputs and that might be a tad alarming to some to see that, however it&rsquo;s worth
remembering that our automatically generated <code>flake.lock</code> will ensure that whatever versions of packages we use do not change without us
intentionally changing them. If the use of the unstable channel is concerning, however, it can be locked to one of the stable releases such as
<code>23.11</code> at the time of this writing.</p><p>Next up, we define our dependencies:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>scriptDeps <span style=color:#f92672>=</span> with pkgs; <span style=color:#f92672>[</span>
</span></span><span style=display:flex><span>    nixFormatter
</span></span><span style=display:flex><span>    jq
</span></span><span style=display:flex><span>    git
</span></span><span style=display:flex><span>    gnugrep
</span></span><span style=display:flex><span>    curl
</span></span><span style=display:flex><span>    kubectl
</span></span><span style=display:flex><span><span style=color:#f92672>]</span>;
</span></span></code></pre></div><p>Every one of these packages will be installed to the environment that our scripts are executed in. For any utilities you want
to add, all you have to do is search for them <a href=https://search.nixos.org/packages>in the NixOS package search</a> and add them to the list! For
example, we added <code>kubectl</code> to the list from <a href="https://search.nixos.org/packages?channel=unstable&amp;from=0&amp;size=50&amp;sort=relevance&amp;type=packages&amp;query=kubectl">this search</a></p><p>Next, we want to make it so that the addition or removal of scripts can be done without needing to touch our Nix code at all. The way we accomplish
this is by having our flake scan the <code>scripts/</code> directory for files that have some predetermined extensions. This means that if someone wants to
add a new script to our project, all they have to do is add it to the <code>scripts/</code> directory with one of the extensions that we specify; no nix code
required!</p><p>We also want to allow multiple &ldquo;types&rdquo; of scripts, automatically determined by extension, so that we can change script headers, footers, or even
dependencies based on the extension of the script. While the demo only includes BASH scripts, this could also allow for running any other types of
scripts such as python, go, or so on. In our demo, we specify two extensions <code>.std.sh</code> and <code>.tf.sh</code> like so:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#75715e># headers here, defined outside the list so they can refer to each other</span>
</span></span><span style=display:flex><span>stdShHeader <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;&#39;</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>#!${pkgs.stdenv.shell}</span>
</span></span><span style=display:flex><span>    set -Eeou pipefail
</span></span><span style=display:flex><span>    export PATH<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;</span>$PATH<span style=color:#e6db74>:</span><span style=color:#e6db74>${</span>scriptEnv<span style=color:#e6db74>}</span><span style=color:#e6db74>/bin&#34;</span>
</span></span><span style=display:flex><span><span style=color:#e6db74>&#39;&#39;</span>;
</span></span><span style=display:flex><span>tfShHeader <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;&#39;</span>
</span></span><span style=display:flex><span>    <span style=color:#e6db74>${</span>stdShHeader<span style=color:#e6db74>}</span>
</span></span><span style=display:flex><span>    echo <span style=color:#e6db74>&#39;Running the extra tasks for .tf.sh&#39;</span>
</span></span><span style=display:flex><span><span style=color:#e6db74>&#39;&#39;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># Define metadata for each file suffix and the headers/exec command to attach to them</span>
</span></span><span style=display:flex><span>scriptSuffixes <span style=color:#f92672>=</span> <span style=color:#f92672>[</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    suffix <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;.std.sh&#34;</span>;
</span></span><span style=display:flex><span>    header <span style=color:#f92672>=</span> stdShHeader;
</span></span><span style=display:flex><span>    command <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;exec&#34;</span>;
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    suffix <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;.tf.sh&#34;</span>;
</span></span><span style=display:flex><span>    header <span style=color:#f92672>=</span> tfShHeader;
</span></span><span style=display:flex><span>    command <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;exec&#34;</span>;
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span><span style=color:#f92672>]</span>;
</span></span></code></pre></div><p>In our usage here, we&rsquo;re defining <code>stdShHeader</code> and <code>tfShHeader</code> outside of our list of suffixes to keep it easy to refer to other headers, but
these could just as easily be defined inline with our list.</p><p>Finally, the real workhorse of our customized flake. This is where we do the actual walking of the <code>scripts/</code> directory using the metadata defined
in the list above:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>scriptMappings <span style=color:#f92672>=</span> builtins.map
</span></span><span style=display:flex><span>        <span style=color:#75715e># for each script suffix we...</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>(</span>typeAttrs:
</span></span><span style=display:flex><span>        let
</span></span><span style=display:flex><span>            <span style=color:#75715e># Find all scripts in the directory with our expected suffix</span>
</span></span><span style=display:flex><span>            scriptsFound <span style=color:#f92672>=</span> builtins.filter <span style=color:#f92672>(</span>name: lib.hasSuffix typeAttrs.suffix name<span style=color:#f92672>)</span> scriptDirScripts;
</span></span><span style=display:flex><span>            <span style=color:#75715e># Map those found scripts to command names such that `format.std.sh` becomes `format`</span>
</span></span><span style=display:flex><span>            scriptNames <span style=color:#f92672>=</span> builtins.map <span style=color:#f92672>(</span>name: builtins.replaceStrings <span style=color:#f92672>[</span> typeAttrs.suffix <span style=color:#f92672>]</span> <span style=color:#f92672>[</span> <span style=color:#e6db74>&#34;&#34;</span> <span style=color:#f92672>]</span> name<span style=color:#f92672>)</span> scriptsFound;
</span></span><span style=display:flex><span>            <span style=color:#75715e># Create a list of maps where the command is set to &#34;name&#34; and the path to the script is set to &#34;value&#34;, e.g. [{&#34;name&#34;:&#34;format&#34;,&#34;value&#34;:&#34;./scripts/format.std.sh&#34;, ...}]</span>
</span></span><span style=display:flex><span>            scriptAttrLists <span style=color:#f92672>=</span> builtins.map <span style=color:#f92672>(</span>name: <span style=color:#f92672>{</span> name <span style=color:#f92672>=</span> name; value <span style=color:#f92672>=</span> scriptDir + <span style=color:#e6db74>&#34;/</span><span style=color:#e6db74>${</span>name<span style=color:#e6db74>}${</span>typeAttrs.suffix<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>; <span style=color:#f92672>})</span> scriptNames;
</span></span><span style=display:flex><span>            <span style=color:#75715e># Convert that list of maps into a single mapping where command name is the key, path is the value. e.g. {&#34;format&#34;:&#34;./scripts/format.std.sh&#34;, ...}</span>
</span></span><span style=display:flex><span>            scriptAttrs <span style=color:#f92672>=</span> builtins.listToAttrs scriptAttrLists;
</span></span><span style=display:flex><span>            <span style=color:#75715e># Finally, instead of JUST the path, add the full formatting of the wrapper script (including the header and exec command) to the values</span>
</span></span><span style=display:flex><span>            <span style=color:#75715e># {&#34;format&#34;: &#34;&lt;all contents of wrapper script&gt;&#34;, ...}</span>
</span></span><span style=display:flex><span>            scriptContents <span style=color:#f92672>=</span> builtins.mapAttrs
</span></span><span style=display:flex><span>            <span style=color:#f92672>(</span>name: value: <span style=color:#e6db74>&#39;&#39;</span>
</span></span><span style=display:flex><span>                <span style=color:#e6db74>${</span>typeAttrs.header<span style=color:#e6db74>}</span>
</span></span><span style=display:flex><span>                <span style=color:#e6db74>${</span>typeAttrs.command<span style=color:#e6db74>}</span> <span style=color:#e6db74>${</span>value<span style=color:#e6db74>}</span> <span style=color:#e6db74>&#34;</span>$@<span style=color:#e6db74>&#34;</span>
</span></span><span style=display:flex><span>            <span style=color:#e6db74>&#39;&#39;</span><span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>            scriptAttrs;
</span></span><span style=display:flex><span>        in
</span></span><span style=display:flex><span>        scriptContents<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>    scriptSuffixes;
</span></span></code></pre></div><p>We&rsquo;ll let the comments in the above snippets do most of the talking, but basically we are creating a script mapping from each of the scripts found
and adding the script headers and exec command. This mapping effectively creates a &ldquo;wrapper&rdquo; script for each one of the scripts found that might look
something like this for the command <code>./run format</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#75715e>#!/usr/bin/env bash
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>set -Eeou pipefail
</span></span><span style=display:flex><span>export PATH<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;</span>$PATH<span style=color:#e6db74>:/nix/store/generated-env-dir/bin&#34;</span>
</span></span><span style=display:flex><span>exec ./scripts/format.std.sh <span style=color:#e6db74>&#34;</span>$@<span style=color:#e6db74>&#34;</span>
</span></span></code></pre></div><h3 id=the-help-command>The Help Command</h3><p>We also want to ensure that our code is as self-documenting as possible while also keeping documentation simple. While this isn&rsquo;t a replacement for
complete documentation by other means, maintaining quick help text can be made semi-automatic. To do this, we can just add another script file to our
project called <code>help.std.sh</code>. You can
<a href=https://github.com/philproctor/nix-script-runner-demo/blob/main/scripts/help.std.sh>see the full contents of the demo help script here</a>.</p><p>In a nutshell what we do though is this:</p><ul><li>Scan the <code>scripts/</code> directory for files that end in the extensions that we care about (<code>.std.sh</code> and <code>.tf.sh</code>)</li><li>For each script that we find, use <code>grep</code> to find the first line of code that starts with <code># HELPTEXT:</code></li><li>Output each script command along with the HELP output in a human readable format.</li></ul><p>The result looks like this:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ ./run help
</span></span><span style=display:flex><span>Usage: ./run &lt;command&gt; <span style=color:#f92672>[</span>args...<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Standard commands:
</span></span><span style=display:flex><span>  format                        Format flake.nix
</span></span><span style=display:flex><span>  help                          Display this help output
</span></span><span style=display:flex><span>  update-packages               Update the flake.lock with the latest version of all dependencies
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Terraform commands:
</span></span><span style=display:flex><span>  test                          Demo <span style=color:#66d9ef>for</span> files with a .tf.sh extension instead
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>note: any arguments passed after &lt;command&gt; are passed directly to the script that handles that command.
</span></span></code></pre></div><h2 id=final-results>Final Results</h2><p>What we&rsquo;re left with after doing this project is a structure that looks like this:</p><ul><li>ðŸ“‚ <code>scripts/</code><ul><li>ðŸ“„ <code>help.std.sh</code></li><li>ðŸ“„ <code>format.std.sh</code></li><li>ðŸ“„ <code>test.tf.sh</code></li><li>ðŸ“„ <code>update-packages.std.sh</code></li></ul></li><li>ðŸ“„ <code>flake.nix</code></li><li>ðŸ“„ <code>flake.lock</code></li><li>ðŸ“„ <code>run</code></li></ul><p>The maintenance once the boilerplate is done is simple:</p><ul><li>Any scripts that we want to add to this project can then simply be added to the <code>scripts/</code> folder with one of our extensions and it will be autodetected as a new <code>run</code> command. Remember that scripts need to be in git <code>git add</code> and need to be executable <code>chmod +x</code>.</li><li>Any new dependencies can be added to <code>scriptDeps</code> inside of <code>flake.nix</code></li><li>Updating the dependency lock can be done with <code>./run update-packages</code></li><li>New types of scripts, such as python scripts, can be supported by amending <code>scriptSuffixes</code> in <code>flake.nix</code> and updating dependencies</li><li>New users of the project do not need to install <strong>any</strong> dependencies except for Nix itself. Our <code>run</code> script will dump a message telling them to install Nix if it&rsquo;s missing.</li></ul><p>So with a little up-front work, we have a project with scripts that will run on anyone&rsquo;s machine, works in any CI environment, self-documents its own commands,
is easy to extend and maintain, and best of all it doesn&rsquo;t require anything other than Nix to run anywhere!</p><p>Would you use this yourself?</p></div></article><hr><div class=post-info><p><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-tag meta-icon"><path d="M20.59 13.41l-7.17 7.17a2 2 0 01-2.83.0L2 12V2h10l8.59 8.59a2 2 0 010 2.82z"/><line x1="7" y1="7" x2="7" y2="7"/></svg><span class=tag><a href=/tags/devops/>devops</a></span>
<span class=tag><a href=/tags/scripting/>scripting</a></span>
<span class=tag><a href=/tags/nix/>nix</a></span>
<span class=tag><a href=/tags/posts/>posts</a></span></p></div></main></div><footer class=footer><div class=footer__inner><div class=footer__content><span>&copy; 2024</span>
<span><a href=/>Phil Proctor</a></span>
<span><a href=https://creativecommons.org/licenses/by-nc/4.0/ target=_blank rel=noopener>CC BY-NC 4.0</a></span>
<span><a href=/posts/index.xml target=_blank title=rss><svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 20 20" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-rss"><path d="M4 11a9 9 0 019 9"/><path d="M4 4a16 16 0 0116 16"/><circle cx="5" cy="19" r="1"/></svg></a></span></div></div></footer></div><script type=text/javascript src=/bundle.min.205d491810c28f95aa953fae884e1c27abe13fdf93ec63b882d0036b248d4a6282eb2d134e4e7225c6ad6e86db87b08488a361ca4a7383d01fcff43f3d57b9c3.js integrity="sha512-IF1JGBDCj5WqlT+uiE4cJ6vhP9+T7GO4gtADaySNSmKC6y0TTk5yJcatbobbh7CEiKNhykpzg9Afz/Q/PVe5ww=="></script></body></html>